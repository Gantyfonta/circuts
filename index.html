<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Redstone Simulator</title>
  <style>
    body {
      background: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    #toolbar {
      margin: 10px;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
    }
    canvas {
      border: 2px solid white;
      background: #222;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <h1>ðŸ”´ Minecraft Redstone Simulator</h1>
  <div id="toolbar">
    <button onclick="selectTool('lever')">Lever</button>
    <button onclick="selectTool('dust')">Redstone Dust</button>
    <button onclick="selectTool('lamp')">Redstone Lamp</button>
    <button onclick="selectTool('block')">Block</button>
    <button onclick="selectTool('repeater')">Repeater</button>
    <button onclick="selectTool(null)">Erase</button>
  </div>
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const gridSize = 15; // 15x15 grid
    const cellSize = canvas.width / gridSize;

    let currentTool = null;

    // Each cell: {type, powered, state}
    const grid = [];
    for (let y = 0; y < gridSize; y++) {
      const row = [];
      for (let x = 0; x < gridSize; x++) {
        row.push(null);
      }
      grid.push(row);
    }

    function selectTool(tool) {
      currentTool = tool;
    }

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);

      let cell = grid[y][x];

      if (cell && cell.type === "lever") {
        // Toggle lever
        cell.state = !cell.state;
      } else {
        // Place new thing
        if (currentTool) {
          grid[y][x] = {type: currentTool, powered: false, state: false};
        } else {
          grid[y][x] = null; // Erase
        }
      }

      updatePower();
      draw();
    });

    function updatePower() {
      // Reset all powered states
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (grid[y][x]) grid[y][x].powered = false;
        }
      }

      // Power propagation
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const cell = grid[y][x];
          if (cell && cell.type === "lever" && cell.state) {
            powerNeighbors(x, y);
          }
        }
      }
    }

    function powerNeighbors(x, y) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) continue;
        const neighbor = grid[ny][nx];
        if (!neighbor) continue;

        if (neighbor.type === "dust") {
          if (!neighbor.powered) {
            neighbor.powered = true;
            powerNeighbors(nx, ny); // chain power
          }
        }
        if (neighbor.type === "lamp") {
          neighbor.powered = true;
        }
        if (neighbor.type === "repeater") {
          neighbor.powered = true;
          powerNeighbors(nx, ny);
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = "#444";
      for (let i = 0; i <= gridSize; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.stroke();
      }

      // Items
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const cell = grid[y][x];
          if (!cell) continue;

          const cx = x * cellSize + cellSize/2;
          const cy = y * cellSize + cellSize/2;

          ctx.font = `${cellSize*0.6}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          if (cell.type === "lever") {
            ctx.fillStyle = cell.state ? "lime" : "gray";
            ctx.fillText("ðŸ”€", cx, cy);
          }
          if (cell.type === "dust") {
            ctx.fillStyle = cell.powered ? "red" : "#550000";
            ctx.beginPath();
            ctx.arc(cx, cy, cellSize/4, 0, Math.PI*2);
            ctx.fill();
          }
          if (cell.type === "lamp") {
            ctx.fillStyle = cell.powered ? "yellow" : "#333";
            ctx.fillRect(x*cellSize+4, y*cellSize+4, cellSize-8, cellSize-8);
          }
          if (cell.type === "block") {
            ctx.fillStyle = "#888";
            ctx.fillRect(x*cellSize+2, y*cellSize+2, cellSize-4, cellSize-4);
          }
          if (cell.type === "repeater") {
            ctx.fillStyle = cell.powered ? "orange" : "#444";
            ctx.fillRect(x*cellSize+6, y*cellSize+10, cellSize-12, cellSize-20);
          }
        }
      }
    }

    draw();
  </script>
</body>
</html>
