<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Redstone Circuit Simulator</title>
  <style>
    body { margin: 0; background: #1e1e1e; color: #ddd; font-family: sans-serif; }
    #toolbar { display: flex; background: #333; padding: 5px; }
    #toolbar button {
      margin: 2px; padding: 5px 10px; cursor: pointer;
      border: none; border-radius: 4px; background: #555; color: #fff;
    }
    #toolbar button.active { background: #ff4444; }
    #container { display: flex; height: calc(100vh - 40px); }
    #gridCanvas { flex: 2; background: #222; cursor: pointer; }
    #guide {
      flex: 1; overflow-y: auto; background: #111;
      padding: 10px; font-size: 14px; line-height: 1.4em;
    }
    h2, h3 { color: #ffcc44; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button data-tool="wire">Wire</button>
    <button data-tool="lever">Lever</button>
    <button data-tool="torch">Torch</button>
    <button data-tool="lamp">Lamp</button>
    <button data-tool="repeater">Repeater</button>
    <button data-tool="comparator">Comparator</button>
  </div>
  <div id="container">
    <canvas id="gridCanvas" width="800" height="600"></canvas>
    <div id="guide">
      <h2>Basic Components and Their Functions</h2>
      <ul>
        <li><b>Redstone Dust:</b> Wiring, decays 1 per block (max 15).</li>
        <li><b>Levers:</b> ON/OFF input (power 15).</li>
        <li><b>Redstone Torch:</b> Constant power unless inverted (NOT gate).</li>
        <li><b>Repeater:</b> Resets signal to 15, adds delay, locks state.</li>
        <li><b>Comparator:</b> Compares back vs. side input.</li>
        <li><b>Lamp:</b> Turns on when powered.</li>
      </ul>

      <h2>Logic Gates</h2>
      <ul>
        <li><b>NOT:</b> Inverts input (Torch).</li>
        <li><b>AND:</b> Two levers → both ON powers lamp.</li>
        <li><b>OR:</b> Either input ON powers lamp.</li>
        <li><b>XOR:</b> Only one input ON powers lamp.</li>
      </ul>

      <h2>Key Concepts</h2>
      <ul>
        <li><b>Ticks:</b> 0.1s time unit. Repeaters add delay.</li>
        <li><b>Signal Strength:</b> 0–15. Repeaters reset to 15.</li>
        <li><b>Binary Logic:</b> Everything ON/OFF.</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 20;
    const rows = canvas.height / gridSize;
    const cols = canvas.width / gridSize;
    let tool = "wire";

    // Grid storage
    const grid = Array.from({ length: rows }, () => Array(cols).fill(null));

    // Tool select
    document.querySelectorAll("#toolbar button").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        tool = btn.dataset.tool;
      });
    });

    // Place/remove blocks
    canvas.addEventListener("click", (e) => {
      const x = Math.floor(e.offsetX / gridSize);
      const y = Math.floor(e.offsetY / gridSize);
      if (grid[y][x] && grid[y][x].type === tool) {
        if (tool === "lever") {
          // toggle lever
          grid[y][x].on = !grid[y][x].on;
        } else {
          grid[y][x] = null;
        }
      } else {
        grid[y][x] = { type: tool, power: 0, on: false };
      }
      updatePower();
      draw();
    });

    // Update cycle
    function updatePower() {
      // Reset power
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          if (grid[y][x]) grid[y][x].power = 0;
        }
      }

      // Queue propagation BFS
      const queue = [];
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          const cell = grid[y][x];
          if (!cell) continue;
          if (cell.type === "lever" && cell.on) {
            cell.power = 15;
            queue.push({x,y,power:15});
          }
          if (cell.type === "torch") {
            // Torch powers unless directly powered
            let powered = isPowered(x,y);
            cell.power = powered ? 0 : 15;
            if (cell.power > 0) queue.push({x,y,power:15});
          }
        }
      }

      while (queue.length > 0) {
        const {x,y,power} = queue.shift();
        if (power <= 0) continue;

        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx,dy] of dirs) {
          const nx = x+dx, ny=y+dy;
          if (nx<0||ny<0||nx>=cols||ny>=rows) continue;
          const neighbor = grid[ny][nx];
          if (!neighbor) {
            // bare wire placement
            grid[ny][nx] = null;
            continue;
          }
          if (neighbor.type === "wire") {
            if (neighbor.power < power-1) {
              neighbor.power = power-1;
              queue.push({x:nx,y:ny,power:power-1});
            }
          }
          if (neighbor.type === "lamp") {
            if (power>0) neighbor.power = power;
          }
          if (neighbor.type === "repeater") {
            // simple: just forward power at full strength
            if (neighbor.power < 15) {
              neighbor.power = 15;
              queue.push({x:nx,y:ny,power:15});
            }
          }
          if (neighbor.type === "comparator") {
            // read back input
            if (neighbor.power < power) {
              neighbor.power = power;
            }
          }
        }
      }
    }

    function isPowered(x,y) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs) {
        const nx=x+dx, ny=y+dy;
        if (nx<0||ny<0||nx>=cols||ny>=rows) continue;
        const neighbor = grid[ny][nx];
        if (neighbor && neighbor.power>0) return true;
      }
      return false;
    }

    // Draw grid
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          ctx.strokeStyle = "#333";
          ctx.strokeRect(x*gridSize, y*gridSize, gridSize, gridSize);
          const cell = grid[y][x];
          if (!cell) continue;

          switch(cell.type) {
            case "wire":
              ctx.fillStyle = cell.power>0 ? "red" : "darkred";
              ctx.fillRect(x*gridSize+5,y*gridSize+5,gridSize-10,gridSize-10);
              break;
            case "lever":
              ctx.fillStyle = cell.on ? "orange" : "gray";
              ctx.fillRect(x*gridSize+4,y*gridSize+4,gridSize-8,gridSize-8);
              break;
            case "torch":
              ctx.fillStyle = cell.power>0 ? "red" : "black";
              ctx.beginPath();
              ctx.arc(x*gridSize+gridSize/2,y*gridSize+gridSize/2,6,0,Math.PI*2);
              ctx.fill();
              break;
            case "lamp":
              ctx.fillStyle = cell.power>0 ? "yellow" : "#444";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              break;
            case "repeater":
              ctx.fillStyle = "lightblue";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              break;
            case "comparator":
              ctx.fillStyle = "purple";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              break;
          }
        }
      }
    }

    // Run tick updates
    setInterval(()=>{ updatePower(); draw(); },200);
    draw();
  </script>
</body>
</html>
