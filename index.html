<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Redstone Circuit Simulator</title>
  <style>
    body { margin: 0; background: #1e1e1e; color: #ddd; font-family: sans-serif; }
    #toolbar { display: flex; background: #333; padding: 5px; }
    #toolbar button {
      margin: 2px; padding: 5px 10px; cursor: pointer;
      border: none; border-radius: 4px; background: #555; color: #fff;
    }
    #toolbar button.active { background: #ff4444; }
    #container { display: flex; height: calc(100vh - 40px); }
    #gridCanvas { flex: 2; background: #222; cursor: pointer; }
    #guide {
      flex: 1; overflow-y: auto; background: #111;
      padding: 10px; font-size: 14px; line-height: 1.4em;
    }
    h2, h3 { color: #ffcc44; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button data-tool="wire">Wire</button>
    <button data-tool="lever">Lever</button>
    <button data-tool="torch">Torch</button>
    <button data-tool="lamp">Lamp</button>
    <button data-tool="repeater">Repeater</button>
    <button data-tool="comparator">Comparator</button>
    <button data-tool="piston">Piston</button>
  </div>
  <div id="container">
    <canvas id="gridCanvas" width="800" height="600"></canvas>
    <div id="guide">
      <h2>Basic Components and Their Functions</h2>
      <ul>
        <li><b>Redstone Dust:</b> Wiring, decays 1 per block (max 15).</li>
        <li><b>Levers:</b> Double-click to toggle ON/OFF (power 15).</li>
        <li><b>Redstone Torch:</b> Constant power unless inverted (NOT gate).</li>
        <li><b>Repeater:</b> Resets signal to 15, adds delay, locks state.</li>
        <li><b>Comparator:</b> Compares back vs. side input.</li>
        <li><b>Lamp:</b> Turns on when powered.</li>
        <li><b>Piston:</b> Extends when powered.</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 20;
    const rows = Math.floor(canvas.height / gridSize);
    const cols = Math.floor(canvas.width / gridSize);
    let tool = "wire";

    const grid = Array.from({ length: rows }, () => Array(cols).fill(null));

    // Tool select
    document.querySelectorAll("#toolbar button").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        tool = btn.dataset.tool;
      });
    });

    // Place/remove blocks (single click = place/remove)
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / gridSize);
      const y = Math.floor((e.clientY - rect.top) / gridSize);

      if (!grid[y][x]) {
        grid[y][x] = { type: tool, power: 0, on: false, dir: 0 };
      } else if (grid[y][x].type === tool) {
        // Remove only if same tool
        grid[y][x] = null;
      }
      updatePower();
      draw();
    });

    // Double click for toggling/rotating
    canvas.addEventListener("dblclick", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / gridSize);
      const y = Math.floor((e.clientY - rect.top) / gridSize);

      const cell = grid[y][x];
      if (!cell) return;

      if (cell.type === "lever") {
        cell.on = !cell.on;
      } else {
        cell.dir = (cell.dir + 1) % 4; // rotate
      }
      updatePower();
      draw();
    });

    function updatePower() {
      // Reset
      for (let y=0; y<rows; y++) for (let x=0; x<cols; x++) if (grid[y][x]) grid[y][x].power = 0;

      const queue = [];
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          const cell = grid[y][x];
          if (!cell) continue;
          if (cell.type === "lever" && cell.on) {
            cell.power = 15;
            queue.push({x,y,power:15});
          }
          if (cell.type === "torch") {
            let powered = isPowered(x,y);
            cell.power = powered ? 0 : 15;
            if (cell.power > 0) queue.push({x,y,power:15});
          }
        }
      }

      while (queue.length > 0) {
        const {x,y,power} = queue.shift();
        if (power <= 0) continue;
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx,dy] of dirs) {
          const nx=x+dx, ny=y+dy;
          if (nx<0||ny<0||nx>=cols||ny>=rows) continue;
          const neighbor = grid[ny][nx];
          if (!neighbor) continue;
          if (neighbor.type === "wire" && neighbor.power < power-1) {
            neighbor.power = power-1;
            queue.push({x:nx,y:ny,power:power-1});
          }
          if (neighbor.type === "lamp" && power>0) neighbor.power = power;
          if (neighbor.type === "repeater" && neighbor.power < 15) {
            neighbor.power = 15;
            queue.push({x:nx,y:ny,power:15});
          }
          if (neighbor.type === "comparator" && neighbor.power < power) {
            neighbor.power = power;
          }
          if (neighbor.type === "piston") {
            neighbor.power = power;
          }
        }
      }
    }

    function isPowered(x,y) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs) {
        const nx=x+dx, ny=y+dy;
        if (nx<0||ny<0||nx>=cols||ny>=rows) continue;
        const neighbor = grid[ny][nx];
        if (neighbor && neighbor.power>0) return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          ctx.strokeStyle = "#333";
          ctx.strokeRect(x*gridSize,y*gridSize,gridSize,gridSize);
          const cell = grid[y][x];
          if (!cell) continue;
          switch(cell.type) {
            case "wire":
              ctx.fillStyle = cell.power>0 ? "red" : "darkred";
              ctx.fillRect(x*gridSize+5,y*gridSize+5,gridSize-10,gridSize-10);
              break;
            case "lever":
              ctx.fillStyle = cell.on ? "orange" : "gray";
              ctx.fillRect(x*gridSize+4,y*gridSize+4,gridSize-8,gridSize-8);
              break;
            case "torch":
              ctx.fillStyle = cell.power>0 ? "red" : "black";
              ctx.beginPath();
              ctx.arc(x*gridSize+gridSize/2,y*gridSize+gridSize/2,6,0,Math.PI*2);
              ctx.fill();
              break;
            case "lamp":
              ctx.fillStyle = cell.power>0 ? "yellow" : "#444";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              break;
            case "repeater":
              ctx.fillStyle = "lightblue";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              ctx.fillStyle = "#000";
              ctx.fillText("â–¶",x*gridSize+6,y*gridSize+14);
              break;
            case "comparator":
              ctx.fillStyle = "purple";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              ctx.fillStyle = "#fff";
              ctx.fillText("C",x*gridSize+6,y*gridSize+14);
              break;
            case "piston":
              ctx.fillStyle = cell.power>0 ? "green" : "darkgreen";
              ctx.fillRect(x*gridSize+2,y*gridSize+2,gridSize-4,gridSize-4);
              if (cell.power>0) {
                ctx.fillStyle = "lime";
                let dx=[1,0,-1,0][cell.dir], dy=[0,1,0,-1][cell.dir];
                ctx.fillRect((x+dx)*gridSize+6,(y+dy)*gridSize+6,gridSize-12,gridSize-12);
              }
              break;
          }
        }
      }
    }

    setInterval(()=>{ updatePower(); draw(); },200);
    draw();
  </script>
</body>
</html>
